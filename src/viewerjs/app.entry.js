import '../pages/Viewer/style.css';
import { createSceneManager } from './sceneManager.js';
import { createUIManager } from './ui.js';
import { createQueryHandler } from './query.js';

// Shared state for the app - initialize but don't create managers yet
let app = null;

export function initializeApp() {
  // Always re-initialize if canvas-container doesn't have a canvas yet
  // This handles the case where the user navigates away and comes back
  const canvasContainer = document.getElementById('canvas-container');
  const hasCanvas = canvasContainer && canvasContainer.querySelector('canvas');
  
  if (app && hasCanvas) {
    // App exists and canvas is properly attached
    console.log('[App] Reusing existing app instance');
    return app;
  }
  
  if (app && !hasCanvas) {
    // Canvas was removed, re-append it
    console.log('[App] Canvas was removed, re-appending');
    if (app.renderer && canvasContainer) {
      canvasContainer.appendChild(app.renderer.domElement);
    }
    return app;
  }
  
  // Use default PLY files
  let plyFiles = ["https://storage.googleapis.com/examples_ply/B3_S4.ply", "https://storage.googleapis.com/examples_ply/B3_S2.ply", "https://storage.googleapis.com/examples_ply/B3_S5.ply"];
  
  app = {
    plyFiles: plyFiles,
    loadedFiles: new Map(),
    renderMode: 'points',
    colorMode: 'original',
    qualityMode: 'downsampled',
    selectedFile: null,
    sceneInfo: null,
    highlightBoxes: new Map(),
    currentMode: 'orbit',
  };

  // Instantiate managers
  app.sceneManager = createSceneManager(app, null);
  app.ui = createUIManager(app, app.sceneManager, null);
  // Ensure scene manager knows about the UI (set after both are created)
  if (app.sceneManager && app.sceneManager.setUI) app.sceneManager.setUI(app.ui);
  app.query = createQueryHandler(app, app.sceneManager, app.ui);

  // Start managers and load files
  app.sceneManager.init();
  (async function start() {
    await loadSceneInfo();
  
  // Show notification if using auto-generated mode
  if (app.sceneInfo && app.sceneInfo._autoGenerated) {
    showAutoGenNotification();
  }
  
  app.ui.createFileCheckboxes();
  // Only load default files if no example was specified via query params
  // The Viewer component will load the selected example if present
  if (!window.location.search.includes('example=')) {
    app.sceneManager.loadAllPLYFiles();
  }
  })();
  
  window.__app = app;
  return app;
}

function showBackendGenNotification() {
  const banner = document.createElement('div');
  banner.id = 'autogen-banner';
  banner.innerHTML = `
    <div style="display: flex; align-items: center; justify-content: space-between;">
      <div style="display: flex; align-items: center; gap: 10px;">
        <span style="font-size: 18px;">✅</span>
        <div>
          <strong>Scene metadata loaded</strong><br>
          <span style="font-size: 12px; opacity: 0.8;">Scene info automatically generated from your PLY files. You can start querying immediately!</span>
        </div>
      </div>
      <button id="dismiss-banner" style="background: rgba(255,255,255,0.1); border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">Dismiss</button>
    </div>
  `;
  
  Object.assign(banner.style, {
    position: 'fixed',
    top: '10px',
    left: '50%',
    transform: 'translateX(-50%)',
    background: 'rgba(76, 175, 80, 0.15)',
    border: '1px solid rgba(76, 175, 80, 0.3)',
    borderRadius: '8px',
    padding: '15px 20px',
    color: '#fff',
    zIndex: '9999',
    maxWidth: '90%',
    width: '600px',
    boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
    animation: 'slideDown 0.3s ease-out'
  });
  
  document.body.appendChild(banner);
  
  document.getElementById('dismiss-banner').addEventListener('click', () => {
    banner.style.animation = 'slideUp 0.3s ease-in';
    setTimeout(() => banner.remove(), 300);
  });
  
  addBannerAnimations();
  
  // Auto-dismiss after 4 seconds
  setTimeout(() => {
    if (document.getElementById('autogen-banner')) {
      banner.style.animation = 'slideUp 0.3s ease-in';
      setTimeout(() => banner.remove(), 300);
    }
  }, 4000);
}

function showAutoGenNotification() {
  const banner = document.createElement('div');
  banner.id = 'autogen-banner';
  banner.innerHTML = `
    <div style="display: flex; align-items: center; justify-content: space-between;">
      <div style="display: flex; align-items: center; gap: 10px;">
        <span style="font-size: 18px;">⚠️</span>
        <div>
          <strong>Fallback mode active</strong><br>
          <span style="font-size: 12px; opacity: 0.8;">Backend server not available. Using frontend auto-generation (slower). Start the backend server for better performance.</span>
        </div>
      </div>
      <button id="dismiss-banner" style="background: rgba(255,255,255,0.1); border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">Dismiss</button>
    </div>
  `;
  
  Object.assign(banner.style, {
    position: 'fixed',
    top: '10px',
    left: '50%',
    transform: 'translateX(-50%)',
    background: 'rgba(255, 152, 0, 0.15)',
    border: '1px solid rgba(255, 152, 0, 0.3)',
    borderRadius: '8px',
    padding: '15px 20px',
    color: '#fff',
    zIndex: '9999',
    maxWidth: '90%',
    width: '600px',
    boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
    animation: 'slideDown 0.3s ease-out'
  });
  
  document.body.appendChild(banner);
  
  document.getElementById('dismiss-banner').addEventListener('click', () => {
    banner.style.animation = 'slideUp 0.3s ease-in';
    setTimeout(() => banner.remove(), 300);
  });
  
  addBannerAnimations();
}

function addBannerAnimations() {
  // Add CSS animation
  if (!document.getElementById('banner-animations')) {
    const style = document.createElement('style');
    style.id = 'banner-animations';
    style.textContent = `
      @keyframes slideDown {
        from { transform: translateX(-50%) translateY(-20px); opacity: 0; }
        to { transform: translateX(-50%) translateY(0); opacity: 1; }
      }
      @keyframes slideUp {
        from { transform: translateX(-50%) translateY(0); opacity: 1; }
        to { transform: translateX(-50%) translateY(-20px); opacity: 0; }
      }
    `;
    document.head.appendChild(style);
  }
}

async function loadSceneInfo() {
  try {
    // First try to load from /info.json (backend should generate this on startup)
    const resp = await fetch('/info.json');
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const json = await resp.json();
    
    // Check if info.json is empty or has no useful data
    if (!json.name || Object.keys(json.name).length === 0) {
      console.warn('[Main] info.json exists but is empty. Requesting backend generation...');
      await requestBackendGeneration();
    } else {
      app.sceneInfo = json;
      buildSceneInfoMaps();
      console.log('[Main] Scene info.json loaded (backend-generated)', app.sceneInfo);
      return;
    }
  } catch (err) {
    console.warn('[Main] Could not load info.json. Requesting backend generation...', err);
    await requestBackendGeneration();
  }
}

async function requestBackendGeneration() {
  try {
    // Try to request backend to generate info.json
    const resp = await fetch('http://localhost:5000/api/scene-info');
    if (resp.ok) {
      const data = await resp.json();
      if (data.success && data.info) {
        app.sceneInfo = data.info;
        buildSceneInfoMaps();
        console.log('[Main] Scene info generated by backend', app.sceneInfo);
        
        // Show a notification that backend generated it
        showBackendGenNotification();
        return;
      }
    }
    throw new Error('Backend generation failed');
  } catch (err) {
    console.warn('[Main] Backend not available or generation failed. Using frontend fallback.', err);
    // Fallback to frontend auto-generation
    app.sceneInfo = { name: {}, bounding_box: {}, labels: {}, _map: new Map(), displayNames: new Map() };
    app.sceneInfo._autoGenerated = true;
    console.log('[Main] Frontend auto-generation mode enabled.');
    showAutoGenNotification();
  }
}

function buildSceneInfoMaps() {
  // Build lookup maps from sceneInfo data
  app.sceneInfo._map = new Map();
  app.sceneInfo.displayNames = new Map();
  
  if (app.sceneInfo.name) {
    for (const key of Object.keys(app.sceneInfo.name)) {
      const val = app.sceneInfo.name[key];
      const filenameLower = String(val).toLowerCase();
      const keyLower = String(key).toLowerCase();
      app.sceneInfo._map.set(keyLower, { key, filename: val });
      app.sceneInfo._map.set(filenameLower, { key, filename: val });
      const basename = filenameLower.replace(/\.ply$/i, '');
      app.sceneInfo._map.set(basename, { key, filename: val });
      const tokens = new Set([...basename.split(/[^a-z0-9]+/), ...keyLower.split(/[^a-z0-9]+/)]);
      for (const t of tokens) if (t && t.length > 0) app.sceneInfo._map.set(t, { key, filename: val });
      const existing = app.sceneInfo.displayNames.get(val) || [];
      if (!existing.includes(key)) existing.push(key);
      app.sceneInfo.displayNames.set(val, existing);
    }
  }
  
  if (app.sceneInfo.bounding_box) {
    for (const key of Object.keys(app.sceneInfo.bounding_box)) {
      app.sceneInfo._map.set(key.toLowerCase(), { key, filename: app.sceneInfo.name?.[key] });
    }
  }
  
  if (app.sceneInfo.labels) {
    for (const [fn, labels] of Object.entries(app.sceneInfo.labels)) {
      for (const lab of labels) {
        app.sceneInfo._map.set(String(lab).toLowerCase(), { 
          key: Object.keys(app.sceneInfo.name).find(k => app.sceneInfo.name[k] === fn) || String(lab).toLowerCase(), 
          filename: fn 
        });
      }
      const existing = app.sceneInfo.displayNames.get(fn) || [];
      for (const lab of labels) if (!existing.includes(lab)) existing.push(lab);
      app.sceneInfo.displayNames.set(fn, existing);
    }
  }
}

export default app;
